$date
	Fri Nov 14 13:26:09 2025
$end
$version
	Icarus Verilog
$end
$timescale
	1ps
$end
$scope module pe $end
$var wire 1 ! clk $end
$var wire 1 " pe_accept_w_in $end
$var wire 1 # pe_enabled $end
$var wire 32 $ pe_input_in [31:0] $end
$var wire 32 % pe_psum_in [31:0] $end
$var wire 1 & pe_switch_in $end
$var wire 1 ' pe_valid_in $end
$var wire 32 ( pe_weight_in [31:0] $end
$var wire 1 ) rst $end
$var wire 32 * mult_out [31:0] $end
$var wire 32 + mac_out [31:0] $end
$var parameter 32 , DATA_WIDTH $end
$var reg 32 - pe_input_out [31:0] $end
$var reg 32 . pe_psum_out [31:0] $end
$var reg 1 / pe_switch_out $end
$var reg 1 0 pe_valid_out $end
$var reg 32 1 pe_weight_out [31:0] $end
$var reg 32 2 weight_reg_active [31:0] $end
$var reg 32 3 weight_reg_inactive [31:0] $end
$scope module adder $end
$var wire 32 4 b [31:0] $end
$var wire 1 5 b_zero $end
$var wire 1 6 b_sign $end
$var wire 1 7 b_nan $end
$var wire 23 8 b_mant [22:0] $end
$var wire 1 9 b_inf $end
$var wire 8 : b_exp [7:0] $end
$var wire 1 ; a_zero $end
$var wire 1 < a_sign $end
$var wire 1 = a_nan $end
$var wire 23 > a_mant [22:0] $end
$var wire 1 ? a_inf $end
$var wire 8 @ a_exp [7:0] $end
$var wire 32 A a [31:0] $end
$var parameter 32 B FORMAT $end
$var parameter 32 C FRAC_BITS $end
$var parameter 32 D INT_BITS $end
$var parameter 32 E WIDTH $end
$var reg 24 F a_mant_ext [23:0] $end
$var reg 24 G b_mant_ext [23:0] $end
$var reg 8 H exp_diff [7:0] $end
$var reg 8 I larger_exp [7:0] $end
$var reg 1 J normalize_done $end
$var reg 32 K result [31:0] $end
$var reg 8 L result_exp [7:0] $end
$var reg 1 M result_sign $end
$var reg 25 N sum_mant [24:0] $end
$var integer 32 O i [31:0] $end
$scope begin fp32_mode $end
$upscope $end
$upscope $end
$scope module mult $end
$var wire 32 P a [31:0] $end
$var wire 32 Q b [31:0] $end
$var parameter 32 R FORMAT $end
$var parameter 32 S FRAC_BITS $end
$var parameter 32 T INT_BITS $end
$var parameter 32 U WIDTH $end
$var reg 10 V a_e [9:0] $end
$var reg 24 W a_m [23:0] $end
$var reg 1 X a_s $end
$var reg 10 Y b_e [9:0] $end
$var reg 24 Z b_m [23:0] $end
$var reg 1 [ b_s $end
$var reg 1 \ guard_bit $end
$var reg 50 ] product [49:0] $end
$var reg 32 ^ result [31:0] $end
$var reg 1 _ round_bit $end
$var reg 1 ` sticky $end
$var reg 10 a z_e [9:0] $end
$var reg 24 b z_m [23:0] $end
$var reg 1 c z_s $end
$upscope $end
$upscope $end
$enddefinitions $end
$comment Show the parameter values. $end
$dumpall
b100000 U
b10000 T
b10000 S
b1000110010100000011001100110010 R
b100000 E
b10000 D
b10000 C
b1000110010100000011001100110010 B
b100000 ,
$end
#0
$dumpvars
xc
bx b
bx a
x`
x_
b0 ^
bx ]
x\
0[
b0 Z
b1110000001 Y
0X
b0 W
b1110000001 V
b0 Q
b0 P
b11111111111111111111111111111111 O
b0 N
xM
b0 L
b0 K
0J
b0 I
b0 H
b0 G
b0 F
b0 A
b0 @
0?
b0 >
0=
0<
1;
b0 :
09
b0 8
07
06
15
b0 4
b0 3
b0 2
b0 1
00
0/
b0 .
b0 -
b0 +
b0 *
0)
b0 (
0'
z&
b0 %
b0 $
z#
0"
1!
$end
#5000
0!
#10000
b100010100000000 (
1"
z/
1!
#15000
0!
#20000
b101000000000 (
b100010100000000 1
b100010100000000 3
1!
#25000
0!
#30000
b11001000000000 +
b11001000000000 K
05
b11001000000000 8
b1000000000 W
b11001000000000 %
b11001000000000 4
b1000000000 $
b1000000000 P
1'
1&
0"
b101000000000 1
b101000000000 3
1!
#35000
0!
#40000
b0 *
b0 A
b0 ^
1`
0_
0\
b0 b
b1010000000000000000000000 ]
b1110000010 a
0c
b10000000000 W
b1110000001 Y
b1110000001 V
b1010000000000 Z
b11001000000000 .
b1000000000 -
b101000000000 2
b101000000000 Q
b0 1
1/
10
1!
#45000
0!
#50000
0'
1!
#55000
0!
#60000
0&
b0 .
00
1!
#65000
0!
#70000
0/
1!
#75000
0!
#80000
1!
#85000
0!
#90000
1!
#90001
